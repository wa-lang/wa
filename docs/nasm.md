# 凹汇编语言(The Wa Native Assembly Language) - 2026

凹汇编语言用于描述本地的汇编语言程序, 支持中英文语法混合使用.

以下是 LOGO:

```
+---+    +---+
| o |    | o |
|   +----+   |
|            |
|    NASM    |
|            |
+------------+
```

汇编代码的后缀名 `.wz.s` 对应中文语法, `.wa.s` 对应 GAS 风格语法, 英文名字缩写: NASM.

目前提供龙芯架构的实现, 未来将考虑提供 RISCV 等其他普通的实现.

### 1. 你好世界 - 龙芯版本

中文版本:

```s
全局 .我的.字符串.数据: 字串 = "hello\n"
全局 .我的.字符串.长度: 四字 = 6

函数 准备:
    # 中文指令...
完毕

函数 主控:
    # 中文指令...
完毕

函数 普通函数:
    # 中文指令...
完毕
```

英文版本:

```s
.section .data
.align 3
.app.hello.str: .asciz "hello\n"
.app.hello.len: .quad 6

.section .text
.globl _start
_start:
    # main
    pcalau12i $t0, %pc_hi20(main)
    addi.d $t0, $t0, %pc_lo12(main)
    jirl $ra, $t0, 0

    # exit
    addi.d $a7, $zero, 93 # sys_exit
    syscall 0

.section .text
.globl main
main:
    addi.d  $sp, $sp, -16
    st.d    $ra, $sp, 8
    st.d    $fp, $sp, 0
    addi.d  $fp, $sp, 0

    # write(stdout, str, len)
    addi.d    $a0, $zero, 1 # arg.0 stdout
    pcalau12i $a1, %pc_hi20(.app.hello.str) # arg.1: ptr
    addi.d    $a1, $a1, %pc_lo12(.app.hello.str)
    pcalau12i $a2, %pc_hi20(.app.hello.len) # arg.2: len
    addi.d    $a2, $a2, %pc_lo12(.app.hello.len)
    ld.d      $a2, $a2, 0
    addi.d    $a7, $zero, 64 # sys_write
    syscall   0

    # return 0
    addi.d $a0, $zero, 0

    addi.d  $sp, $fp, 0
    ld.d    $ra, $sp, 8
    ld.d    $fp, $sp, 0
    addi.d  $sp, $sp, 16
    jirl    $zero, $ra, 0
```

## 2. 中文语法

凹汇编语言中文语法提供中文关键字, 中文指令名, 中文寄存器名, 提供了定义常量/全局变量/函数等能力.

### 2.1. 注释

`#` 开头的一行为注释

### 2.2. 标识符

和C语言的标识符类似, 以字母下划线开头, 后续可以是字母和数字和下划线. 同时`.`和`$`也被视作字母.

特别的`_`时垃圾桶标识符, 主要用于内存对齐占位置, 无法被引用.

### 2.3. 声明

```
声明 ABC
```

声明一个内存地址符号`ABC`, 更多用于注释. 最终的链接时必须保证声明的符号在当前源文件中定义.

### 2.4. 全局变量

```
全局 .我的.年龄: 双字 = 1

全局 .我的.字符串.长度: 四字 = 6
全局 .我的.字符串.数据: 字串 = "hello\n"

全局 .我的.指针: 地址 = .我的.字符串.数据
```

全局变量有以下几种大小的空间:

- `字节`, 1个字节, 用整数/字符面值初始化
- `单字`, 2个字节, 用整数/字符面值初始化
- `双字`, 4个字节, 用整数/字符面值初始化
- `四字`, 8个字节, 用整数/字符面值初始化
- `单精`, 4个字节, 单精度浮点数, 用整数/浮点数初始化
- `双精`, 8个字节, 双精度浮点数, 用整数/浮点数初始化
- `地址`, 类型指针, 和整数寄存器宽度一致, 只能用其他标识符来初始化
- `字串`, 二进制字符串

其中`字串`类型以1字节对齐, 其他数据对齐到该类型的大小.

### 2.5. 只读数据

```
只读 .我的.字符串.数据: 字串 = "hello\n"
只读 .我的.字符串.长度: 四字 = 6
```

和全局变量的规则一样, 但是在`.rodata`段分配空间, 运行时只读.

### 2.6. 定义函数

函数需要绑定到代码段(`.text`), 并且必须4字节对齐:

```s
# 内存初始化函数
函数 内存初始化:
    # 中文指令...
完毕
```

### 2.7. 特殊的函数

- `准备`时启动时调用一次
- `主控`是类似`main`的入口函数
- `_启动`是汇编的入口函数, 缺少时会自动生成, 也可手动调用`准备`和`主控`

### 2.8. 地址对齐

- 全局变量会根据基础类型的大小对齐
- 字符串等空间以1字节对齐, 空字符串也至少占一个字节空间(结尾有`\0`填充)
- 函数强制以4字节对齐
- 缺少部分GAS语法补充

## 3. 英文语法

凹汇编语言英文版本是GAS语法的子集, 针对全局变量/函数等定义做了更为严格的约束. 英语语法的凹汇编语言理论上可以直接用GCC汇编器编译, 但是反之则不行. 这里介绍凹汇编语言英文语法的核心特性.

### 3.1. 注释

`#` 开头的一行为注释

### 3.2. 标识符

和C语言的标识符类似, 以字母下划线开头, 后续可以是字母和数字和下划线. 同时`.`和`$`也被视作字母.

### 3.3. 全局变量

全局变量需要绑定到数据段(`.data`和`.rodata`), 并且指令地址的对齐方式:

```s
.section .data
.align 3
.Table.funcIndexList.0: .quad .Import.syscall.write
```

表示在 `.data` 数据段定义了 `.Table.funcIndexList.0` 的全局变量, 对应8个字节内存空间, 初始值是 `.Import.syscall.write` 函数的地址. 对于龙芯, 变量的地址是 `2^3=8` 字节对齐(X64平台会有差异, 目前忽略).

全局变量有以下类型:

- `.byte`, 1个字节
- `.short`, 2个字节
- `.long`, 4个字节
- `.quad`, 8个字节
- `.float`, 4个字节, 单精度浮点数, 用整数/浮点数初始化
- `.double`, 8个字节, 双精度浮点数, 用整数/浮点数初始化
- `.ascii`, ASCII字符串
- `.skip`, 一段0填充的内存
- `.incbin`, 包含外部的数据文件(最大2MB)

预留一定字节的空间:

```s
.section .data
.align 3
.globl .some.table
.some.table: .skip 100
```

以上是预留100字节的空间, 地址是`2^3=8`字节对齐.

包含外部的资源文件:

```s
.image.data: .incbin "lena.jpg"
```

### 3.4. 定义函数

函数需要绑定到代码段(`.text`), 并且必须4字节对齐:

```s
# 内存初始化函数
.section .text
.align 3
.globl .Wa.Memory.initFunc
.Wa.Memory.initFunc:
    push rbp
    mov  rbp, rsp
    sub  rsp, 32
    ...
```

表示在 `.text` 代码段定义了 `.Wa.Memory.initFunc` 函数, 函数开始地址在龙芯平台为 `2^2=4` 字节对齐, 并且通过 `.globl` 导出了函数的名字. 最后以函数名开头的标号, 后面是函数的指令.

### 3.5. 特殊情况

凹语言自带的汇编器不支持链接外部的符号, 对于 `.extern _Wa_Runtime_write` 语法凹语言汇编器可以解析但是不能链接, 这种情况可以用gcc汇编器.

对于未来可能会支持的X64汇编语言, 必须在开头加上 `.intel_syntax noprefix` 指令, 表示使用 intel 的指令语法风格, 同时去掉寄存器和立即数开头的`%`和`$`等前缀.

GAS语法中`.globl`和`.global`是两个等价的命令, 用于标志符号是导出的, 前者是Unix时代汇编器短名字的习惯. 凹汇编语言能识别两者, 但格式化时会强制输出为`.globl`短名字格式.

## 4. 指令中的宏

在不同的CPU类型平台不仅有不同的指令集, 也针对指令的特点定义了不同的宏.

### 4.1. 中文版特有的宏

- `%内存字节数(symbol)`: 计算全局变量内存大小, 全平台支持

### 4.2. 龙芯平台的宏

英文版本和龙芯GCC汇编的宏语义一致:

- `%abs_lo12(symbol)`: 绝对地址低12bit
- `%abs_hi20(symbol)`: 绝对地址高20bit
- `%abs_lo20(symbol)`: 绝对地址低20bit
- `%abs_hi12(symbol)`: 绝对地址高12bit
- `%pc_lo12(symbol)`: PC相对地址低12bit
- `%pc_hi20(symbol)`: PC相对地址高20bit
- `%pc_lo20(symbol)`: PC相对地址低20bit
- `%pc_hi12(symbol)`: PC相对地址高12bit

对应的中文版本的宏:

- `%绝对.低12(符号)`: 绝对地址低12bit
- `%绝对.高20(符号)`: 绝对地址高20bit
- `%绝对64.低20(符号)`: 绝对地址低20bit
- `%绝对64.高12(符号)`: 绝对地址高12bit
- `%相对.低12(符号)`: PC相对地址低12bit
- `%相对.高20(符号)`: PC相对地址高20bit
- `%相对64.低20(符号)`: PC相对地址低20bit
- `%相对64.高12(符号)`: PC相对地址高12bit

## 5. 调试信息

凹语言自研汇编器暂不支持生成调试信息, 但是会正确解析并跳过以下的调试伪指令:

- `.file 1, "file.wa"`: 全局指令, 文件编号
- `.loc  1 2 3`: 函数内指令, 指令对应的源文件位置, 比如 1 号文件, 第 2 行, 第 3 列
- `.size man, .-main`: 全局指令, 函数大小. 注意这里的表达式不能在地方使用
- `.type name, @function`: 全局指令, 符号类型, 数据为 @object. 函数的类型必须在函数标号之前

如果希望生成调试信息, 可以GAS语法兼容部分可以无缝切换为gcc命令生成目标文件.

## 6. 补充说明

凹汇编语言的中英文语法和混合使用, 凹语言的汇编器可以解析. 如果希望用GCC来编译中英文语法混合的凹汇编程序, 需要提供凹语言计划提供的命令行工具导出纯GAS语法再用GCC编译.


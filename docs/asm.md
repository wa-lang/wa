# 凹汇编语言

主要是内部用于表示 龙芯 等本地的汇编语言程序.

## 注释

- 支持 `#` 开头的单行注释

## 语句

- 语句以分号分割
- 每个换行符号可能会自动插入分号
- 同一个指令不会跨越多行

## 名字

- 关键字为小写字母, 比如 `func` 表示定义函数, `global` 表示定义全局变量
- 全局标识符以 `$` 开头, 比如 `$main` 表示 main 函数
- 局部标识符以 `%` 开头, 比如 `%a` 表示局部变量名
- 指令不区分大小写, 比如 `CALL` 和 `call` 等价
- 寄存器不区分大小写, 比如 `PC` 和 `pc` 等价
- `_.$`和字母数字都是合法的字符

## 关键字

- `i32`: `int32`
- `i64`: `int64`
- `u32`: `uint32`
- `u64`: `uint64`
- `f32`: `float32`
- `f64`: `float63`
- `ptr`: uint pointer
- `const`: 定义全局常量(不含字符串)
- `global`: 定义全局变量
- `func`: 定义函数
- 寄存器: 平台相关定义
- 指令: 平台相关定义

## 关键字(中文)

```go
	I32_zh    // 整32
	I64_zh    // 整64
	U32_zh    // 无整32
	U64_zh    // 无整64
	F32_zh    // 浮32
	F64_zh    // 浮64
	PTR_zh    // 指针
	CONST_zh  // 常量
	GLOBAL_zh // 全局
	FUNC_zh   // 函数
```

## 字面值

- 默认整数类型: `123` 为 `i32`
- 默认浮点数类型: `12.3` 为 `f32`
- 不支持表达式: 不支持 `1+2` 写法
- 字符常量: `'A'`/`'1'`, 为 `i32` 对应字符的码点值
- 整数常量: `123`, 数字部分支持二进制/十进制/十六进制等
- 浮点数常量: `1.5`/`123.456`, 数字部分支持普通浮点数/科学计数法/十六进制等
- 字符串常量: 支持单行字符串, 转义规则参考凹语言
- 地址常量: 标识符表示的地址, `ptr` 类型

## 全局常量

常量和面值一样有类型(整数/浮点数/地址), 目的是为了更精确记录原始的字面值. 常量的值不支持运算表达式, 也不支持引用其他标识符.

```go
# 默认常量类型
const $A = 'A' # i32
const $B = 123 # i32
const $C = 1.5 # f32

# 指定常量类型
const $D = i64('D') # i64
const $E = f64(456) # f64, 接受 int 和 float
const $F = f64(1.5)

# 无符号类型
const $H = u32(0xABCD) # u32
const $I = u64(0xABCD) # u64

# 地址类型
const $P = ptr(0xABCD) # ptr, 只接受正整数

# 字符串
const $S = "abcd" # STRING

# 错误的用法
# const $A = 1+2
# const $B = $A
```

## 全局变量

- 变量只是一段内存, 只有内存大小, 没有类型
- 但常量的初始化值有类型

```go
# 默认的i32
global $age: i32 = 5
global $ch: i32 = 'A'

# 默认的f32
global $size: f32 = 12.3

# 整数, 4字节, 12345678 
global $i32: i32 = 12345678

# 整数, 8字节, 0x12345678
global $i64: i64 = 0x12345678

# float32
global $f32: f32 = 12.5

# float64
global $f64: f64 = 12.34567

# utf8 编码的字符串, 结尾自动添加 `\0`, 地址和长度自动对齐到 8 字节
global $name = "wa native assembly language"
```

全局变量可以指定更大的长度:

```go
global $f32: 20 = f32(12.5)

# 指定长度的字符串, 不足部分补充0
global $str: 100 = "abc"
```

分段初始化(类似结构体):

```go
# 1024 字节结构体
# pos: value, 只能是用基础常量面值初始化
global $info: 1024 = {
    5: "abc",    # 从第5字节开始 `abc\0`
    9: i32(123), # 从第9字节开始
}
```

用常量初始化:

```go
global $ptr = $UART0 # 常量没有地址
```

用`$info`地址初始化:

```go
global $ptr = $info # $info 的地址
```

## 函数

定义函数:

```go
func $add(%a: i32, %b: i32) => i32 {
    # 局部变量
    local %sum: i32
    local %tab: [32]i32

    # 指令
Loop:
}
```

参数和局部变量类似一个局部常量, 定义了相对于栈帧都有固定的偏移量.

## 指令中的宏

- `%hi(symbol)`: 绝对地址高20bit
- `%lo(symbol)`: 绝对地址低12bit
- `%pcrel_hi(symbol)`: PC相对地址高20bit
- `%pcrel_lo(label)`: PC相对地址低12bit, 参数是 `%pcrel_hi(symbol)` 对应的 `label`
- `%sizeof(symbol)`: 计算全局变量内存大小
- `%高位(symbol)`: 绝对地址高20bit
- `%低位(symbol)`: 绝对地址低12bit
- `%相对高位(symbol)`: PC相对地址高20bit
- `%相对低位(label)`: PC相对地址低12bit, 参数是 `%pcrel_hi(symbol)` 对应的 `label`
- `%内存字节数(symbol)`: 计算全局变量内存大小

## 例子(中文版)

QEMU 裸机输出字符串的例子:

```
# 兼容 QEMU virt 机器 串口 和 关机 的基地址
常量 $串口 = 0x10000000
常量 $关机 = 0x100000

# 用于输出的字符串
全局 $信札 = "你好, 龙的传人(Loongson Baremetal)!\n\x00"

# 主函数
函数 _启动:
%开篇:
    # 参甲格 = 字符串地址
    计加正12立 参甲格, %相对高位($信札)        # 高20位 = 当前PC + 偏移
    加立.字    参甲格, 参甲格, %相对低位(%开篇) # 低12位

%精卫填海:
    装载.微正  参乙格, 参甲格, 0   # 取一个字节
    跳转.相等  参乙格, 零格, %收工 # 如果是0则结束

    # 暂甲格 = 串口 值
    装载上部12立.字 暂甲格, %高位($串口)           # 串口 高20位
    加立.字        暂甲格, 暂甲格, %低位($串口)    # 串口 低12位

    存储.微 参乙格, 暂甲格, 0        # 写到 串口 寄存器
    加立.字 参甲格, 参甲格, 1        # 下一个字符
    跳转    %精卫填海

%收工:
    # 写退出码 0 到 关机, 退出
    装载上部12立.字 暂甲格, %高位($关机)     # 关机寄存器地址
    加立.字 暂甲格, 暂甲格, %低位($关机)

    # 暂乙格 = 0x5555
    装载上部12立.字 暂乙格, 0x5             # 高 20 位 (0x5 << 12 = 0x5000)
    加立.字        暂乙格, 暂乙格, 0x555    # 结果 = 0x5000 + 0x555 = 0x5555

    存储.字 暂乙格, 暂甲格, 0

    # 如果不支持 关机设备，就进入 苦海无边 死循环
%苦海:
    跳转  %苦海
完毕
```

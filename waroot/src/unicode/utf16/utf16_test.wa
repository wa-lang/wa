// Copyright (C) 2026 武汉凹语言科技有限公司
// SPDX-License-Identifier: MIT

import "unicode"

// Validate the constants redefined from unicode.
func TestConstants {
	if MaxRune != unicode.MaxRune {
		assert(false)
		// t.Errorf("utf16.maxRune is wrong: %x should be %x", MaxRune, unicode.MaxRune)
	}
	if ReplacementChar != unicode.ReplacementChar {
		assert(false)
		// t.Errorf("utf16.replacementChar is wrong: %x should be %x", ReplacementChar, unicode.ReplacementChar)
	}
}

func TestRuneLen {
	for _, tt := range []struct {
		r:      rune
		length: int
	}{
		{0, 1},
		{Surr1 - 1, 1},
		{Surr3, 1},
		{SurrSelf - 1, 1},
		{SurrSelf, 2},
		{MaxRune, 2},
		{MaxRune + 1, -1},
		{-1, -1},
	} {
		if length := RuneLen(tt.r); length != tt.length {
			assert(false)
			// t.Errorf("RuneLen(%#U) = %d, want %d", tt.r, length, tt.length)
		}
	}
}

type encodeTest :struct {
	in:  []rune
	out: []uint16
}

global encodeTests = []encodeTest{
	{
		[]rune{1, 2, 3, 4},
		[]uint16{1, 2, 3, 4},
	},
	{
		[]rune{0xffff, 0x10000, 0x10001, 0x12345, 0x10ffff},
		[]uint16{0xffff, 0xd800, 0xdc00, 0xd800, 0xdc01, 0xd808, 0xdf45, 0xdbff, 0xdfff},
	},
	{
		[]rune{'a', 'b', 0xd7ff, 0xd800, 0xdfff, 0xe000, 0x110000, -1},
		[]uint16{'a', 'b', 0xd7ff, 0xfffd, 0xfffd, 0xe000, 0xfffd, 0xfffd},
	},
}

func TestEncode {
	for _, tt := range encodeTests {
		out := Encode(tt.in)
		if !tU16SliceEqual(out, tt.out) {
			assert(false)
			//t.Errorf("Encode(%x) = %x; want %x", tt.in, out, tt.out)
		}
	}
}

func TestAppendRune {
	for _, tt := range encodeTests {
		out: []uint16
		for _, u := range tt.in {
			out = AppendRune(out, u)
		}
		if !tU16SliceEqual(out, tt.out) {
			assert(false)
			//t.Errorf("AppendRune(%x) = %x; want %x", tt.in, out, tt.out)
		}
	}
}

func TestEncodeRune {
	for _, tt := range encodeTests {
		j := 0
		for _, r := range tt.in {
			r1, r2 := EncodeRune(r)
			if r < 0x10000 || r > unicode.MaxRune {
				if j >= len(tt.out) {
					assert(false)
					//t.Errorf("#%d: ran out of tt.out", i)
					break
				}
				if r1 != unicode.ReplacementChar || r2 != unicode.ReplacementChar {
					assert(false)
					//t.Errorf("EncodeRune(%#x) = %#x, %#x; want 0xfffd, 0xfffd", r, r1, r2)
				}
				j++
			} else {
				if j+1 >= len(tt.out) {
					assert(false)
					//t.Errorf("#%d: ran out of tt.out", i)
					break
				}
				if r1 != rune(tt.out[j]) || r2 != rune(tt.out[j+1]) {
					assert(false)
					// t.Errorf("EncodeRune(%#x) = %#x, %#x; want %#x, %#x", r, r1, r2, tt.out[j], tt.out[j+1])
				}
				j += 2
				dec := DecodeRune(r1, r2)
				if dec != r {
					assert(false)
					//t.Errorf("DecodeRune(%#x, %#x) = %#x; want %#x", r1, r2, dec, r)
				}
			}
		}
		if j != len(tt.out) {
			assert(false)
			//t.Errorf("#%d: EncodeRune didn't generate enough output", i)
		}
	}
}

type decodeTest :struct {
	in:  []uint16
	out: []rune
}

global decodeTests = []decodeTest{
	{
		[]uint16{1, 2, 3, 4},
		[]rune{1, 2, 3, 4},
	},
	{
		[]uint16{0xffff, 0xd800, 0xdc00, 0xd800, 0xdc01, 0xd808, 0xdf45, 0xdbff, 0xdfff},
		[]rune{0xffff, 0x10000, 0x10001, 0x12345, 0x10ffff},
	},
	{
		[]uint16{0xd800, 'a'},
		[]rune{0xfffd, 'a'},
	},
	{
		[]uint16{0xdfff},
		[]rune{0xfffd},
	},
}

func TestDecode {
	for _, tt := range decodeTests {
		out := Decode(tt.in)
		if !tRuneSliceEqual(out, tt.out) {
			assert(false)
			//t.Errorf("Decode(%x) = %x; want %x", tt.in, out, tt.out)
		}
	}
}

global decodeRuneTests = []struct {
	r1, r2: rune
	want:   rune
}{
	{0xd800, 0xdc00, 0x10000},
	{0xd800, 0xdc01, 0x10001},
	{0xd808, 0xdf45, 0x12345},
	{0xdbff, 0xdfff, 0x10ffff},
	{0xd800, 'a', 0xfffd}, // illegal, replacement rune substituted
}

func TestDecodeRune {
	for _, tt := range decodeRuneTests {
		got := DecodeRune(tt.r1, tt.r2)
		if got != tt.want {
			assert(false)
			//t.Errorf("%d: DecodeRune(%q, %q) = %v; want %v", i, tt.r1, tt.r2, got, tt.want)
		}
	}
}

global surrogateTests = []struct {
	r:    rune
	want: bool
}{
	// from https://en.wikipedia.org/wiki/UTF-16
	{'\u007A', false},     // LATIN SMALL LETTER Z
	{'\u6C34', false},     // CJK UNIFIED IDEOGRAPH-6C34 (water)
	{'\uFEFF', false},     // Byte Order Mark
	{'\U00010000', false}, // LINEAR B SYLLABLE B008 A (first non-BMP code point)
	{'\U0001D11E', false}, // MUSICAL SYMBOL G CLEF
	{'\U0010FFFD', false}, // PRIVATE USE CHARACTER-10FFFD (last Unicode code point)

	{rune(0xd7ff), false}, // surr1-1
	{rune(0xd800), true},  // surr1
	{rune(0xdc00), true},  // surr2
	{rune(0xe000), false}, // surr3
	{rune(0xdfff), true},  // surr3-1
}

func TestIsSurrogate {
	for _, tt := range surrogateTests {
		got := IsSurrogate(tt.r)
		if got != tt.want {
			assert(false)
			//t.Errorf("%d: IsSurrogate(%q) = %v; want %v", i, tt.r, got, tt.want)
		}
	}
}

func tU16SliceEqual(a, b: []uint16) => bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

func tRuneSliceEqual(a, b: []rune) => bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

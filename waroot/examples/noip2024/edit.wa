// NOIP 2024 第1题
// https://www.luogu.com.cn/problem/P11361

import (
	"os"
	"strconv"
	"strings"
)

func parseList(s: string) => (list: []int) {
	for _, c := range s {
		switch c {
		case '0':
			list = append(list, 0)
		case '1':
			list = append(list, 1)
		default:
			panic("unreachable")
		}
	}
	return
}

func main {
	data := os.StdinData()

	lines := strings.Split(strings.TrimSpace(string(data)), "\n")
	count, err := strconv.Atoi(lines[0])
	if err != nil {
		panic(err.Error())
	}

	for i := 0; i < count; i++ {
		off := i*5 + 1
		S1 := parseList(lines[off+1])
		S2 := parseList(lines[off+2])
		T1 := parseList(lines[off+3])
		T2 := parseList(lines[off+4])
		N := len(S1)

		v := solve(N, S1, S2, T1, T2)
		println(v)
	}

}

// 解题思路
//
// 某个位置, 2个列表根据锁定情况分为3种:
// 1. 两个都锁定: 这种直接判断即可
// 2. 有一个锁定: 则取对方列表可达的区间摘一个0或1进行配对
// 3. 两个都自由: 遍历当前列表剩余的每个元素, 去对方可达的区间摘一个0或1进行配对

// 区间0和1分别计数
// 同一个连通区间的每个元素共享同一个计数
type RangeCount :struct {
	Start, End: int // 左开右闭区间
	TCount:     int // count(1)
	FCount:     int // count(0)
}

// 统计区间计数
func buildRangeCount(n: int, s, t: []int) => (list: []*RangeCount) {
	list = make([]*RangeCount, n)

	currentRange: *RangeCount

	for i := 0; i < n; i++ {
		// 被锁定的情况
		if t[i] == 0 {
			// 清除当前的 RangeCount
			if currentRange != nil {
				currentRange.End = i
				currentRange = nil
			}
			continue
		}

		// 如果当前还没有开始任何区间, 则开始一个新的
		if currentRange == nil {
			currentRange = &RangeCount{Start: i, End: n, TCount: 0, FCount: 0}
		}

		// 将当前位置映射到 RangeCount
		list[i] = currentRange

		// 统计当前字符
		if s[i] == 1 {
			currentRange.TCount++
		} else { // s[i] == 0
			currentRange.FCount++
		}
	}

	return
}

func solve(n: int, s1, s2, t1, t2: []int) => int {
	// 初始化两个列表的自由区间计数
	x1 := buildRangeCount(n, s1, t1)
	x2 := buildRangeCount(n, s2, t2)

	// 第1类情形
	aCount := 0
	for i := 0; i < n; i++ {
		if t1[i] == 0 && t2[i] == 0 {
			if s1[i] == s2[i] {
				aCount++
			}
		}
	}

	// 第2类情形
	bCount := 0
	for i := 0; i < n; i++ {
		if t1[i] == 0 && t2[i] == 0 {
			// 跳过 第1类情形
			continue
		}
		if t1[i] == 1 && t2[i] == 1 {
			// 跳过 第3类情形
			continue
		}

		// 分别从对方列表的连通区间吃掉一个匹配的
		if t1[i] == 0 {
			bCount += tryEat(i, s1[i], x2)
		}
		if t2[i] == 0 {
			bCount += tryEat(i, s2[i], x1)
		}
	}

	// 第3类情形
	cCount := 0
	for i := 0; i < n; i++ {
		if t1[i] == 0 || t2[i] == 0 {
			// 跳过第1/2类情形
			continue
		}

		// 当前位置能搬运的最大个数
		step := maxRangeCountOverlap(x1[i], x2[i])

		// 消除对方区间的匹配
		// 交叉的区间有一个最大值
		for k := 0; x1[i].TCount > 0 && k < step; k++ {
			if x := tryEat(i, 1, x2); x > 0 {
				x1[i].TCount--
				cCount++
			} else {
				break
			}
		}
		for k := 0; x1[i].FCount > 0 && k < step; k++ {
			if x := tryEat(i, 0, x2); x > 0 {
				x1[i].FCount--
				cCount++
			} else {
				break
			}
		}

		// 跳过当前重叠的区间
		i += step - 1
	}

	return aCount + bCount + cCount
}

// 尝试吃掉期望的的值
func tryEat(idx, expectValue: int, x: []*RangeCount) => int {
	if x[idx] == nil {
		return 0
	}
	if expectValue == 1 {
		if x[idx].TCount > 0 {
			x[idx].TCount--
			return 1
		}
	} else {
		if x[idx].FCount > 0 {
			x[idx].FCount--
			return 1
		}
	}
	return 0
}

// 两个区间最大的重叠区域
func maxRangeCountOverlap(a, b: *RangeCount) => int {
	if a == nil || b == nil {
		return 0
	}
	if a.Start >= b.End {
		return 0
	}
	if b.Start >= a.End {
		return 0
	}

	start := maxInt(a.Start, b.Start)
	end := minInt(a.End, b.End)

	return end - start
}

func maxInt(a, b: int) => int {
	if a >= b {
		return a
	}
	return b
}
func minInt(a, b: int) => int {
	if a <= b {
		return a
	}
	return b
}

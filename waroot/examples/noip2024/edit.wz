注: NOIP 2024 第1题
注: https://www.luogu.com.cn/problem/P11361

注: 解题思路
注:
注: 某个位置, 2个列表根据锁定情况分为3种:
注: 1. 两个都锁定: 这种直接判断即可
注: 2. 有一个锁定: 则取对方列表可达的区间摘一个0或1进行配对
注: 3. 两个都自由: 遍历当前列表剩余的每个元素, 去对方可达的区间摘一个0或1进行配对

引入 "字串包"
引入 "字串转译"
引入 "操作系统"

函数·主控:
	数据 := 操作系统·标准输入数据()

	行列表 := 字串包·分隔(字串包·删首尾空白(字串(数据)), "\n")
	数据集个数, 有错 := 字串转译·字串到整数(行列表[0])
	如果 有错 != 空:
		崩溃(有错·报错信息())
	完毕

	循环 甲 := 0; 甲 < 数据集个数; 甲++:
		偏移 := 甲*5 + 1
		数据集甲 := 解析输入列表(行列表[偏移+1])
		数据集乙 := 解析输入列表(行列表[偏移+2])
		甲权限 := 解析输入列表(行列表[偏移+3])
		乙权限 := 解析输入列表(行列表[偏移+4])
		列表长 := 长度(数据集甲)

		结果 := 解题(列表长, 数据集甲, 数据集乙, 甲权限, 乙权限)
		输出(结果)
	完毕
完毕

函数·解析输入列表(一行数据: 字串) => (列表: []整型):
	循环 _, 字符 := 迭代 一行数据:
		找辙 字符:
		有辙 '0':
			列表 = 追加(列表, 0)
		有辙 '1':
			列表 = 追加(列表, 1)
		没辙:
			崩溃("太阳从西边出来了")
		完毕
	完毕
	返回
完毕

注: 区间0和1分别计数
注: 同一个连通区间的每个元素共享同一个计数
结构·区间计数器:
	开始, 结束: 整型 注: 左开右闭区间
	幺个数:     整型 注: count(1)
	洞个数:     整型 注: count(0)
完毕

函数·构建区间计数器列表(n: 整型, s, t: []整型) => (列表: []*区间计数器):
	列表 = 构建([]*区间计数器, n)

	设定·当前区间: *区间计数器

	循环 i := 0; i < n; i++:
		注: 被锁定的情况
		如果 t[i] == 0:
			注: 清除当前的 区间计数器
			如果 当前区间 != 空:
				当前区间·结束 = i
				当前区间 = 空
			完毕
			继续
		完毕

		注: 如果当前还没有开始任何区间, 则开始一个新的
		如果 当前区间 == 空:
			当前区间 = &区间计数器{开始: i, 结束: n, 幺个数: 0, 洞个数: 0}
		完毕

		注: 将当前位置映射到 区间计数器
		列表[i] = 当前区间

		注: 统计当前字符
		如果 s[i] == 1:
			当前区间·幺个数++
		否则: 注: s[i] == 0
			当前区间·洞个数++
		完毕
	完毕

	返回
完毕

函数·解题(数据集个数: 整型, 数据集甲, 数据集乙, 甲权限, 乙权限: []整型) => 整型:
	n, s1, s2, t1, t2 := 数据集个数, 数据集甲, 数据集乙, 甲权限, 乙权限

	注: 初始化两个列表的自由区间计数
	x1 := 构建区间计数器列表(n, s1, t1)
	x2 := 构建区间计数器列表(n, s2, t2)

	第1类情形计数 := 0
	循环 i := 0; i < n; i++:
		如果 t1[i] == 0 && t2[i] == 0:
			如果 s1[i] == s2[i]:
				第1类情形计数++
			完毕
		完毕
	完毕

	第2类情形计数 := 0
	循环 i := 0; i < n; i++:
		如果 t1[i] == 0 && t2[i] == 0:
			注: 跳过 第1类情形
			继续
		完毕
		如果 t1[i] == 1 && t2[i] == 1:
			注: 跳过 第3类情形
			继续
		完毕

		注: 分别从对方列表的连通区间吃掉一个匹配的
		如果 t1[i] == 0:
			第2类情形计数 += 尝试吃一个期望的的值(i, s1[i], x2)
		完毕
		如果 t2[i] == 0:
			第2类情形计数 += 尝试吃一个期望的的值(i, s2[i], x1)
		完毕
	完毕

	第3类情形计数 := 0
	循环 i := 0; i < n; i++:
		如果 t1[i] == 0 || t2[i] == 0:
			注: 跳过第1/2类情形
			继续
		完毕

		注: 当前位置能搬运的最大个数
		step := 两个区间最大的重叠区长度(x1[i], x2[i])

		注: 消除对方区间的匹配
		注: 交叉的区间有一个最大值
		循环 k := 0; x1[i]·幺个数 > 0 && k < step; k++:
			如果 x := 尝试吃一个期望的的值(i, 1, x2); x > 0:
				x1[i]·幺个数--
				第3类情形计数++
			否则:
				跳出
			完毕
		完毕
		循环 k := 0; x1[i]·洞个数 > 0 && k < step; k++:
			如果 x := 尝试吃一个期望的的值(i, 0, x2); x > 0:
				x1[i]·洞个数--
				第3类情形计数++
			否则:
				跳出
			完毕
		完毕

		注: 跳过当前重叠的区间
		i += step - 1
	完毕

	返回 第1类情形计数 + 第2类情形计数 + 第3类情形计数

完毕

函数·尝试吃一个期望的的值(所在位置, 期望值: 整型, 计数列表: []*区间计数器) => 整型:
	如果 计数列表[所在位置] == 空:
		返回 0
	完毕
	如果 期望值 == 1:
		如果 计数列表[所在位置]·幺个数 > 0:
			计数列表[所在位置]·幺个数--
			返回 1
		完毕
	否则:
		如果 计数列表[所在位置]·洞个数 > 0:
			计数列表[所在位置]·洞个数--
			返回 1
		完毕
	完毕
	返回 0
完毕

函数·两个区间最大的重叠区长度(甲, 乙: *区间计数器) => 整型:
	如果 甲 == 空 || 乙 == 空:
		返回 0
	完毕
	如果 甲·开始 >= 乙·结束:
		返回 0
	完毕
	如果 甲·开始 >= 甲·结束:
		返回 0
	完毕

	开始 := 最大整数(甲·开始, 乙·开始)
	结束 := 最小整数(甲·结束, 乙·结束)

	返回 结束 - 开始
完毕

函数·最大整数(甲, 乙: 整型) => 整型:
	如果 甲 >= 乙:
		返回 甲
	完毕
	返回 乙
完毕

函数·最小整数(甲, 乙: 整型) => 整型:
	如果 甲 <= 乙:
		返回 甲
	完毕
	返回 乙
完毕

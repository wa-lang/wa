// Auto generated by Wa Compiler, DONOT EDIT!!!

class WaApp {
  constructor() {
    this._wasm_url = "./p5app.wasm";
    this._mem_util = this._createMemUtil();
    this._wasm_inst = null;
    this._wa_print_buf = "";
  }

  _createMemUtil = () => {
    return {
      mem: () => { return this._wasm_inst.exports.memory; },
      mem_view: (addr, len) => { return new DataView(this._mem_util.mem().buffer, addr, len); },
      mem_array_u8: (addr, len) => { return new Uint8Array(this._mem_util.mem().buffer, addr, len); },
      mem_array_u16: (addr, len) => { return new Uint16Array(this._mem_util.mem().buffer, addr, len); },
      mem_array_u32: (addr, len) => { return new Uint32Array(this._mem_util.mem().buffer, addr, len); },
      mem_array_i32: (addr, len) => { return new Int32Array(this._mem_util.mem().buffer, addr, len); },
      mem_array_f32: (addr, len) => { return new Float32Array(this._mem_util.mem().buffer, addr, len); },
      mem_array_f64: (addr, len) => { return new Float64Array(this._mem_util.mem().buffer, addr, len); },
      get_string: (d, l) => { return new TextDecoder("utf-8").decode(this._mem_util.mem_view(d, l)); },
      set_string: (s) => {
        const bytes = new TextEncoder("utf-8").encode(s);
        const l = bytes.length;
        const bd = this._wasm_inst.exports["runtime.Block.HeapAlloc"](l, 0, 1);
        this._mem_util.mem_array_u8(bd[1], l).set(bytes);
        return [bd[0], bd[1], l];
      },
      get_bytes: (d, l) => { return this._mem_util.mem_array_u8(d, l).slice(0); },
      set_bytes: (bytes) => {
        const l = bytes.length;
        const c = l;
        const bd = this._wasm_inst.exports["runtime.Block.HeapAlloc"](l, 0, 1);
        this._mem_util.mem_array_u8(bd[1], l).set(bytes);
        return [bd[0], bd[1], l, c];
      },
      block_release: (addr) => { this._wasm_inst.exports["runtime.Block.Release"](addr); },
      //基本类型直接读写：
      bool_load: (addr) => { return this._mem_util.mem_array_u8(addr, 1)[0] != 0; },
      bool_store: (addr, v) => {
        if (v) {
          this._mem_util.mem_array_u8(addr, 1)[0] = 1;
        } else {
          this._mem_util.mem_array_u8(addr, 1)[0] = 0;
        }
      },
      u8_load: (addr) => { return this._mem_util.mem_array_u8(addr, 1)[0]; },
      u8_store: (addr, v) => { this._mem_util.mem_array_u8(addr, 1)[0] = v; },
      u16_load: (addr) => { return this._mem_util.mem_array_u16(addr, 1)[0]; },
      u16_store: (addr, v) => { this._mem_util.mem_array_u16(addr, 1)[0] = v; },
      u32_load: (addr) => { return this._mem_util.mem_array_u32(addr, 1)[0]; },
      u32_store: (addr, v) => { this._mem_util.mem_array_u32(addr, 1)[0] = v; },
      i32_load: (addr) => { return this._mem_util.mem_array_i32(addr, 1)[0]; },
      i32_store: (addr, v) => { this._mem_util.mem_array_i32(addr, 1)[0] = v; },
      rune_load: (addr) => { return String.fromCodePoint(this._mem_util.mem_array_u32(addr, 1)[0]); },
      rune_store: (addr, v) => { this._mem_util.mem_array_u32(addr, 1)[0] = v.codePointAt(0); },
      f32_load: (addr) => { return this._mem_util.mem_array_f32(addr, 1)[0]; },
      f32_store: (addr, v) => { this._mem_util.mem_array_f32(addr, 1)[0] = v; },
      f64_load: (addr) => { return this._mem_util.mem_array_f64(addr, 1)[0]; },
      f64_store: (addr, v) => { this._mem_util.mem_array_f64(addr, 1)[0] = v; },
      string_load: (addr) => {
        const d = this._mem_util.i32_load(addr + 4);
        const l = this._mem_util.i32_load(addr + 8);
        return this._mem_util.get_string(d, l);
      },
      string_store: (addr, v) => {
        const b = this._mem_util.i32_load(addr);
        this._mem_util.block_release(b);
        let ns = this._mem_util.set_string(v);
        this._mem_util.i32_store(addr, ns[0]);
        this._mem_util.i32_store(addr + 4, ns[1]);
        this._mem_util.i32_store(addr + 8, ns[2]);
      },
      extract_string: (arr) => {
        const s = this._mem_util.get_string(arr[1], arr[2]);
        this._mem_util.block_release(arr[0]);
        arr.splice(0, 3);
        return s;
      },
      extract_bytes: (arr) => {
        const b = this._mem_util.get_bytes(arr[1], arr[2]);
        this._mem_util.block_release(arr[0]);
        arr.splice(0, 4);
        return b
      },
      extract_bool: (arr) => { const v = arr[0]; arr.splice(0, 1); return v?true:false; },
      extract_rune: (arr) => { const v = arr[0]; arr.splice(0, 1); return String.fromCodePoint(v); },
      extract_number: (arr) => { const v = arr[0]; arr.splice(0, 1); return v; },
    }
  };

  _createSyscall = () => {
    return {
      print_position: (pos) => { this._wa_print_buf += pos },
      print_bool: (b) => { this._wa_print_buf += Boolean(b).toString(); },
      print_u32: (i) => {
        if (i < 0) {
          i += 4294967296;
        }
        this._wa_print_buf += i;
      },
      print_i32: (i) => { this._wa_print_buf += i },
      print_u64: (i) => { this._wa_print_buf += i },
      print_i64: (i) => { this._wa_print_buf += i },
      print_f32: (f) => { this._wa_print_buf += f },
      print_f64: (f) => { this._wa_print_buf += f },
      print_ptr: (p) => { this._wa_print_buf += p },
      print_str: (addr, len) => { this._wa_print_buf += this._mem_util.get_string(addr, len);},
      proc_exit: (code) => { alert(code) },
      print_rune: (c) => {
        let ch = String.fromCodePoint(c);
        if (ch == "\n") {
          console.log(this._wa_print_buf);
          this._wa_print_buf = "";
        }
        else {
          this._wa_print_buf += ch;
        }
      }
    }
  };

  async init() {
    const app = this;
    const imports = {
      syscall_js: this._createSyscall(),
      
// ---------------------------------------------------------
// package: js
// ---------------------------------------------------------

// file: extobj.import.js

extobj: new function() {
  this._obj_buf = [{}];
  this._free_ids = [];
  this.new_obj = () => {
    let obj = {}
    let h = this._free_ids.length > 0
      ? this._free_ids.pop()
      : this._obj_buf.length
    this._obj_buf[h] = obj;
    return h
  }
  this.free_obj = (h) => {
    let obj = this._obj_buf[h];
    // obj.free(); // TODO: 释放资源
    this._obj_buf[h] = null;
    this._free_ids.push(h);
  }
  this.insert_obj = (obj) => {
    let h = this.new_obj()
    this._obj_buf[h] = obj
    return h
  }
  this.get_obj = (h) => {
    return this._obj_buf[h];
  }
  this.set_obj = (h, obj) => {
    this._obj_buf[h] = obj;
  }
  this.query_selector = (sel_b, sel_d, sel_l) => {
    const selector = app._mem_util.get_string(sel_d, sel_l);
    const obj = document.querySelector(selector);
    if (obj) {
      return this.insert_obj(obj);
    } else {
      return 0;
    }
  }
  this.set_member_bool = (h, member_name_b, member_name_d, member_name_l, value) => {
    let member_name = app._mem_util.get_string(member_name_d, member_name_l);
    if (value === 0){
      this._obj_buf[h][member_name] = false;
    } else {
      this._obj_buf[h][member_name] = true;
    }
  }
  this.set_member_i32 = (h, member_name_b, member_name_d, member_name_l, value) => {
    let member_name = app._mem_util.get_string(member_name_d, member_name_l);
    this._obj_buf[h][member_name] = value;
  }
  this.set_member_f32 = (h, member_name_b, member_name_d, member_name_l, value) => {
    let member_name = app._mem_util.get_string(member_name_d, member_name_l);
    this._obj_buf[h][member_name] = value;
  }
  this.set_member_string = (h, name_b, name_d, name_l, value_b, value_d, value_l) => {
    let name = app._mem_util.get_string(name_d, name_l);
    let value = app._mem_util.get_string(value_d, value_l);
    this._obj_buf[h][name] = value;
  }
  this.set_member_obj = (h, member_name_b, member_name_d, member_name_l, value) => {
    if (value > 0) {
      let member_name = app._mem_util.get_string(member_name_d, member_name_l);
      this._obj_buf[h][member_name] = this._obj_buf[value];
    }    
  }
  this.new_array = () => {
    let arr = [];
    let h = this._free_ids.length > 0
      ? this._free_ids.pop()
      : this._obj_buf.length
    this._obj_buf[h] = arr
    return h
  }
  this.append_i32 = (h, value) => {
    this._obj_buf[h].push(value);
  }
  this.append_string = (h, value_b, value_d, value_l) => {
    let value = app._mem_util.get_string(value_d, value_l);
    this._obj_buf[h].push(value);
  }
  this.append_obj = (h, value) => {
    if (value > 0) {
      this._obj_buf[h].push(this._obj_buf[value]);
    }
  }
  app._extobj = this;
},
// ---------------------------------------------------------
// package: js/canvas
// ---------------------------------------------------------

// file: canvas.import.js

canvas: new function() {
  this.set_width_height = (canvas_handle, width, height) => {
    if (canvas_handle == 0) return;
    const canvas = app._extobj.get_obj(canvas_handle);
    canvas.width = width;
    canvas.height = height;
  }

  this.get_context2d = (h) => {
    if (h == 0) return 0;

    const canvas = app._extobj.get_obj(h);
    const ctx = canvas.getContext("2d");
    if (ctx) {
      return app._extobj.insert_obj(ctx);
    }

    return 0;
  }
  this.set_fill_style = (ctx_handle, style_b, style_d, style_l) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    const style = app._mem_util.get_string(style_d, style_l);
    ctx.fillStyle = style;
  }
  this.set_stroke_style = (ctx_handle, style_b, style_d, style_l) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    const style = app._mem_util.get_string(style_d, style_l);
    ctx.strokeStyle = style;
  }
  this.set_shadow_color = (ctx_handle, color_b, color_d, color_l) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    const color = app._mem_util.get_string(color_d, color_l);
    ctx.shadowColor = color;
  }
  this.set_shadow_blur = (ctx_handle, blur) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.shadowBlur = blur;
  }
  this.set_shadow_offset_x = (ctx_handle, offset_x) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.shadowOffsetX = offset_x;
  }
  this.set_shadow_offset_y = (ctx_handle, offset_y) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.shadowOffsetY = offset_y;
  }
  this.create_linear_gradient = (ctx_handle, x0, y0, x1, y1) => {
    // TODO: 待完善
  }
  this.create_pattern = (ctx_handle, image_handle, repeat_b, repeat_d, repeat_l) => {
    // TODO: 待完善
  }
  this.create_radial_gradient = (ctx_handle, x0, y0, r0, x1, y1, r1) => {
    // TODO: 待完善
  }
  this.add_color_stop = (ctx_handle, stop, color_b, color_d, color_l) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    const color = app._mem_util.get_string(color_d, color_l);
    ctx.addColorStop(stop, color);
  }
  this.set_line_cap = (ctx_handle, cap_b, cap_d, cap_l) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    const cap = app._mem_util.get_string(cap_d, cap_l);
    ctx.lineCap = cap;
  }
  this.set_line_join = (ctx_handle, join_b, join_d, join_l) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    const join = app._mem_util.get_string(join_d, join_l);
    ctx.lineJoin = join;
  }
  this.set_line_width = (ctx_handle, width) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.lineWidth = width;
  }
  this.set_miter_limit = (ctx_handle, limit) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.miterLimit = limit;
  }
  this.fill = (ctx_handle) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.fill();
  }
  this.stroke = (ctx_handle) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.stroke();
  }
  this.begin_path = (ctx_handle) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.beginPath();
  }
  this.move_to = (ctx_handle, x, y) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.moveTo(x, y);
  }
  this.close_path = (ctx_handle) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.closePath();
  }
  this.line_to = (ctx_handle, x, y) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.lineTo(x, y);
  }
  this.clip = (ctx_handle) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.clip();
  }
  this.quadratic_curve_to = (ctx_handle, cpx, cpy, x, y) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.quadraticCurveTo(cpx, cpy, x, y);
  }
  this.bezier_curve_to = (ctx_handle, cp1x, cp1y, cp2x, cp2y, x, y) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  }
  this.arc = (ctx_handle, x, y, r, sAngle, eAngle) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.arc(x, y, r, sAngle, eAngle, false);
  }
  this.arc_with_direction = (ctx_handle, x, y, r, sAngle, eAngle, counterclockwise) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.arc(x, y, r, sAngle, eAngle, counterclockwise);
  }

  this.arc_to = (ctx_handle, x1, y1, x2, y2, r) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.arcTo(x1, y1, x2, y2, r);
  }
  this.ellipse = (ctx_handle, x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
  }
  this.is_point_in_path = (ctx_handle, x, y) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    return ctx.isPointInPath(x, y);
  }
  this.rect = (ctx_handle, x, y, w, h) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.rect(x, y, w, h);
  }
  this.fill_rect = (ctx_handle, x, y, w, h) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.fillRect(x, y, w, h);
  }
  this.stroke_rect = (ctx_handle, x, y, w, h) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.strokeRect(x, y, w, h);
  }
  this.clear_rect = (ctx_handle, x, y, w, h) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.clearRect(x, y, w, h);
  }
  this.scale = (ctx_handle, scale_width, scale_height) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.scale(scale_width, scale_height);
  }
  this.rotate = (ctx_handle, angle) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.rotate(angle);
  }
  this.translate = (ctx_handle, x, y) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.translate(x, y);
  }
  this.transform = (ctx_handle, a, b, c, d, e, f) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.transform(a, b, c, d, e, f);
  }
  this.set_transform = (ctx_handle, a, b, c, d, e, f) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.setTransform(a, b, c, d, e, f);
  }
  this.set_font = (ctx_handle, font_b, font_d, font_l) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    const font = app._mem_util.get_string(font_d, font_l);
    ctx.font = font;
  }
  this.set_text_align = (ctx_handle, align_b, align_d, align_l) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    const align = app._mem_util.get_string(align_d, align_l);
    ctx.textAlign = align;
  }
  this.set_text_baseline = (ctx_handle, baseline_b, baseline_d, baseline_l) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    const baseline = app._mem_util.get_string(baseline_d, baseline_l);
    ctx.textBaseline = baseline;
  }
  this.fill_text = (ctx_handle, text_b, text_d, text_l, x, y) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    const text = app._mem_util.get_string(text_d, text_l);
    ctx.fillText(text, x, y);
  }
  this.fill_text_with_max_width = (ctx_handle, text_b, text_d, text_l, x, y, max_width) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    const text = app._mem_util.get_string(text_d, text_l);
    ctx.fillText(text, x, y, max_width);
  }
  this.stroke_text = (ctx_handle, text_b, text_d, text_l, x, y) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    const text = app._mem_util.get_string(text_d, text_l);
    ctx.strokeText(text, x, y);
  }
  this.stroke_text_with_max_width = (ctx_handle, text_b, text_d, text_l, x, y, max_width) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    const text = app._mem_util.get_string(text_d, text_l);
    ctx.strokeText(text, x, y, max_width);
  }
  this.measure_text = (ctx_handle, text_b, text_d, text_l) => {
    // TODO: 待完善
  }
  this.measure_text_with_max_width = (ctx_handle, text_b, text_d, text_l, max_width) => {
    // TODO: 待完善
  }
  this.draw_image = (ctx_handle, img_data_b, img_data_d, img_data_l, img_data_c, dx, dy, dwidth, dheight) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    const buf = new Uint8ClampedArray(app._mem_util.mem().buffer, img_data_d, img_data_l);
    const image = new ImageData(buf, dwidth, dheight);
    ctx.drawImage(image, dx, dy, dwidth, dheight);
  }
  this.draw_image_cropped = (ctx_handle, img_data_b, img_data_d, img_data_l, img_data_c, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    const buf = new Uint8ClampedArray(app._mem_util.mem().buffer, img_data_d, img_data_l);
    const image = new ImageData(buf, swidth, sheight);
    ctx.drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
  }
  this.create_image_data = (ctx_handle, w, h) => {
    // TODO: 待完善
  }
  this.get_image_data = (ctx_handle, x, y, w, h, buf_b, buf_d, buf_l, buf_c) => {
    // TODO: 待完善
  }
  this.put_image_data = (ctx_handle, img_data_b, img_data_d, img_data_l, img_data_c, dx, dy, dirty_x, dirty_y, dirty_w, dirty_h) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    const buf = new Uint8ClampedArray(app._mem_util.mem().buffer, img_data_d, img_data_l);
    const image = new ImageData(buf, dirty_w, dirty_h);
    ctx.putImageData(image, dx, dy, dirty_x, dirty_y, dirty_w, dirty_h);
  }
  this.set_global_alpha = (ctx_handle, alpha) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.globalAlpha = alpha;
  }
  this.set_global_composite_operation = (ctx_handle, op_b, op_d, op_l) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    const op = app._mem_util.get_string(op_d, op_l);
    ctx.globalCompositeOperation = op;
  }
  this.save = (ctx_handle) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.save();
  }
  this.restore = (ctx_handle) => {
    if (ctx_handle == 0) return;

    const ctx = app._extobj.get_obj(ctx_handle);
    ctx.restore();
  }

  app._canvas = this;
},
// ---------------------------------------------------------
// package: js/p5
// ---------------------------------------------------------

// file: p5.import.js

p5js: new function() {
    const p5js = this;
    const theApp = app;

    theApp._p5js = p5js;

    this._inited = false;

    // 初始化
    this.init = () => {
        if(this._inited) { return; }
        this._inited = true;

        // 有 main 函数则不生成框架代码
        if(theApp.main || theApp.主控) { return; }

        // 生成空的 main 函数
        theApp.main = () => {}

        // 键盘消息
        document.addEventListener('keydown', (event) => {

            // 保持定义一致
            const keyCode_Enter = 13;
            const keyCode_Tab = 9;
            const keyCode_Space = 32;
            const keyCode_ArrowUp = 1004;
            const keyCode_ArrowDown = 1005;
            const keyCode_ArrowLeft = 1006;
            const keyCode_ArrowRight = 1007;
            const keyCode_Escape = 1008;
            const keyCode_Backspace = 1009;
            const keyCode_Delete = 1010;
            const keyCode_Shift = 1011;
            const keyCode_Control = 1012;
            const keyCode_Option = 1013;
            const keyCode_Alt = 1014;

            // 保持和凹语言环境定义一致
            switch (event.key) {
            case "Enter":
                theApp.p5js_onKeyDown(keyCode_Enter);
                return;
            case "Tab":
                theApp.p5js_onKeyDown(keyCode_Tab);
                return;
            case " ":
                theApp.p5js_onKeyDown(keyCode_Space);
                return;

            case "ArrowUp":
                theApp.p5js_onKeyDown(keyCode_ArrowUp);
                return;
            case "ArrowDown":
                theApp.p5js_onKeyDown(keyCode_ArrowDown);
                return;
            case "ArrowLeft":
                theApp.p5js_onKeyDown(keyCode_ArrowLeft);
                return;
            case "ArrowRight":
                theApp.p5js_onKeyDown(keyCode_ArrowRight);
                return;

            case "Escape":
                theApp.p5js_onKeyDown(keyCode_Escape);
                return;
            case "Backspace":
                theApp.p5js_onKeyDown(keyCode_Backspace);
                return;
            case "Delete":
                theApp.p5js_onKeyDown(keyCode_Delete);
                return;

            case "Shift":
                theApp.p5js_onKeyDown(keyCode_Shift);
                return;
            case "Control":
                theApp.p5js_onKeyDown(keyCode_Control);
                return;
            case "Meta":
                theApp.p5js_onKeyDown(keyCode_Option);
                return;
            case "Alt":
                theApp.p5js_onKeyDown(keyCode_Alt);
                return;

            default:
                theApp.p5js_onKeyDown(event.keyCode);
                return;
            }
        });
        document.addEventListener('keyup', (event) => {
            theApp.p5js_onKeyUp();
        });

        // 鼠标按键消息
        const canvas = document.getElementById("canvas");
        if(canvas) {

            // 焦点事件
            canvas.addEventListener("focus", (event) => {    
                theApp.p5js_onFocus();
            }, true);
            canvas.addEventListener("blur", (event) => {    
                theApp.p5js_onBlur();
            }, true);

            canvas.addEventListener("mouseenter", (event) => {    
                theApp.p5js_onMouseEnter();
            });
            canvas.addEventListener("mouseleave", (event) => {    
                theApp.p5js_onMouseLeave();
            });

            canvas.addEventListener("mousedown", (event) => {    
                theApp.p5js_onMouseDown(
                    event.button, event.offsetX, event.offsetY
                );
            });
            canvas.addEventListener("mouseup", (event) => {    
                theApp.p5js_onMouseUp();
            });

            canvas.addEventListener("mousemove", (event) => {
                theApp.p5js_onMouseMoved(event.offsetX, event.offsetY);
            });
        }

        // 帧函数
        if(theApp.画画 && typeof theApp.画画 === 'function') {
            let stepAnima = function (timeStamp) {
                theApp.p5js_onDraw_before(timeStamp/1000.0);
                theApp.画画();
                theApp.p5js_onDraw_after();

                window.requestAnimationFrame(stepAnima);
            }
            window.requestAnimationFrame(stepAnima);
        } else if(theApp.Draw && typeof theApp.Draw === 'function') {
            let stepAnima = function (timeStamp) {
                theApp.p5js_onDraw_before(timeStamp/1000.0);
                theApp.Draw();
                theApp.p5js_onDraw_after();

                window.requestAnimationFrame(stepAnima);
            }
            window.requestAnimationFrame(stepAnima);
        }
    }
},

      // ...
    };

    try {
      const source = await fetch(this._wasm_url);
      const result = await WebAssembly.instantiateStreaming(source, imports);
      this._wasm_inst = result.instance;

      // 全局变量：
      

      // 全局函数：
      
      this.p5js_onBlur = function() {
        // 准备参数
        let params = [];
        
        
        let res = this._wasm_inst.exports["p5js_onBlur"](...params);
        
        if (!Array.prototype.isPrototypeOf(res)) {
          res = [res];
        }
        
        
        
      }
      
      this.p5js_onDraw_after = function() {
        // 准备参数
        let params = [];
        
        
        let res = this._wasm_inst.exports["p5js_onDraw_after"](...params);
        
        if (!Array.prototype.isPrototypeOf(res)) {
          res = [res];
        }
        
        
        
      }
      
      this.p5js_onDraw_before = function(timeStamp) {
        // 准备参数
        let params = [];
        params.push(timeStamp);

        
        let res = this._wasm_inst.exports["p5js_onDraw_before"](...params);
        
        if (!Array.prototype.isPrototypeOf(res)) {
          res = [res];
        }
        
        
        
      }
      
      this.p5js_onFocus = function() {
        // 准备参数
        let params = [];
        
        
        let res = this._wasm_inst.exports["p5js_onFocus"](...params);
        
        if (!Array.prototype.isPrototypeOf(res)) {
          res = [res];
        }
        
        
        
      }
      
      this.p5js_onKeyDown = function(keyCode) {
        // 准备参数
        let params = [];
        params.push(keyCode);

        
        let res = this._wasm_inst.exports["p5js_onKeyDown"](...params);
        
        if (!Array.prototype.isPrototypeOf(res)) {
          res = [res];
        }
        
        
        
      }
      
      this.p5js_onKeyUp = function() {
        // 准备参数
        let params = [];
        
        
        let res = this._wasm_inst.exports["p5js_onKeyUp"](...params);
        
        if (!Array.prototype.isPrototypeOf(res)) {
          res = [res];
        }
        
        
        
      }
      
      this.p5js_onMouseDown = function(button, x, y) {
        // 准备参数
        let params = [];
        params.push(button);
params.push(x);
params.push(y);

        
        let res = this._wasm_inst.exports["p5js_onMouseDown"](...params);
        
        if (!Array.prototype.isPrototypeOf(res)) {
          res = [res];
        }
        
        
        
      }
      
      this.p5js_onMouseEnter = function() {
        // 准备参数
        let params = [];
        
        
        let res = this._wasm_inst.exports["p5js_onMouseEnter"](...params);
        
        if (!Array.prototype.isPrototypeOf(res)) {
          res = [res];
        }
        
        
        
      }
      
      this.p5js_onMouseLeave = function() {
        // 准备参数
        let params = [];
        
        
        let res = this._wasm_inst.exports["p5js_onMouseLeave"](...params);
        
        if (!Array.prototype.isPrototypeOf(res)) {
          res = [res];
        }
        
        
        
      }
      
      this.p5js_onMouseMoved = function(x, y) {
        // 准备参数
        let params = [];
        params.push(x);
params.push(y);

        
        let res = this._wasm_inst.exports["p5js_onMouseMoved"](...params);
        
        if (!Array.prototype.isPrototypeOf(res)) {
          res = [res];
        }
        
        
        
      }
      
      this.p5js_onMouseUp = function() {
        // 准备参数
        let params = [];
        
        
        let res = this._wasm_inst.exports["p5js_onMouseUp"](...params);
        
        if (!Array.prototype.isPrototypeOf(res)) {
          res = [res];
        }
        
        
        
      }
      
      this.画画 = function() {
        // 准备参数
        let params = [];
        
        
        let res = this._wasm_inst.exports["p5app.画画"](...params);
        
        if (!Array.prototype.isPrototypeOf(res)) {
          res = [res];
        }
        
        
        
      }
      

      this._wasm_inst.exports._start();
      return this
    } catch (error) {
      console.error('WASM 初始化失败:', error);
    }
  }

}  // class WaApp

export {WaApp}
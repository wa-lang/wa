func $builtin.panic {
    # TODO
}

# TODO: 代码需要验证
func $builtin.memcpy(dst: i64, src: i64, len: i32) {
    move    $t0, $a0        # 备份目标地址用于返回

.L_memcpy_loop8:
    addi.d  $t1, $zero, 8
    blt     $a2, $t1, .L_memcpy_loop1
    ld.d    $t2, $a1, 0     # 加载 8 字节
    st.d    $t2, $a0, 0     # 存储 8 字节
    addi.d  $a0, $a0, 8
    addi.d  $a1, $a1, 8
    addi.d  $a2, $a2, -8
    b       .L_memcpy_loop8

.L_memcpy_loop1:
    beq     $a2, $zero, .L_memcpy_done
    ld.b    $t2, $a1, 0
    st.b    $t2, $a0, 0
    addi.d  $a0, $a0, 1
    addi.d  $a1, $a1, 1
    addi.d  $a2, $a2, -1
    b       .L_memcpy_loop1

.L_memcpy_done:
    move    $a0, $t0
    jr      $ra
}

# TODO: 代码需要验证
func $builtin.memset(dst: i64, v: int32, len: i32) {
    move    $t0, $a0        # 备份起始地址用于返回
    # 将填充值(1字节)扩展到整个64位寄存器中
    andi    $a1, $a1, 0xff  # 只取低8位
    slli.d  $t1, $a1, 8
    or      $a1, $a1, $t1   # 填充 16 位
    slli.d  $t1, $a1, 16
    or      $a1, $a1, $t1   # 填充 32 位
    slli.d  $t1, $a1, 32
    or      $a1, $a1, $t1   # 现在 $a1 包含 8 个重复的填充字节

.L_memset_loop8:
    addi.d  $t1, $zero, 8
    blt     $a2, $t1, .L_memset_loop1 # 长度不足8字节，跳出
    st.d    $a1, $a0, 0     # 一次存 8 字节
    addi.d  $a0, $a0, 8     # 指针后移
    addi.d  $a2, $a2, -8    # 长度减 8
    b       .L_memset_loop8

.L_memset_loop1:
    beq     $a2, $zero, .L_memset_done
    st.b    $a1, $a0, 0     # 存 1 字节
    addi.d  $a0, $a0, 1
    addi.d  $a2, $a2, -1
    b       .L_memset_loop1

.L_memset_done:
    move    $a0, $t0        # 返回原始地址
    jr      $ra
}

# TODO: 代码需要验证
func $builtin.pcnt.w(x: i32) => i32 {
    # t1 = a0 - ((a0 >> 1) & 0x55555555)
    srli.w  $t0, $a0, 1
    lu12i.w $t1, 0x55555       # 高20位
    ori     $t1, $t1, 0x555    # 低12位 -> 0x55555555
    and     $t0, $t0, $t1
    sub.w   $a0, $a0, $t0

    # a0 = (a0 & 0x33333333) + ((a0 >> 2) & 0x33333333)
    srli.w  $t0, $a0, 2
    lu12i.w $t1, 0x33333
    ori     $t1, $t1, 0x333    # -> 0x33333333
    and     $t0, $t0, $t1
    and     $a0, $a0, $t1
    add.w   $a0, $a0, $t0

    # a0 = (a0 + (a0 >> 4)) & 0x0F0F0F0F
    srli.w  $t0, $a0, 4
    add.w   $a0, $a0, $t0
    lu12i.w $t1, 0x0f0f0
    ori     $t1, $t1, 0xf0f    # -> 0x0F0F0F0F
    and     $a0, $a0, $t1

    # a0 = (a0 * 0x01010101) >> 24
    lu12i.w $t1, 0x01010
    ori     $t1, $t1, 0x101    # -> 0x01010101
    mul.w   $a0, $a0, $t1
    srli.w  $a0, $a0, 24
    jirl    $zero, $ra, 0      # 返回
}

# TODO: 代码需要验证
func $builtin.pcnt.d(x: i64) => i32 {
    # 准备掩码寄存器
    lu12i.w $t4, 0x55555
    ori     $t4, $t4, 0x555    # t4 = 0x55555555
    lu12i.w $t5, 0x33333
    ori     $t5, $t5, 0x333    # t5 = 0x33333333
    lu12i.w $t6, 0x0f0f0
    ori     $t6, $t6, 0xf0f    # t6 = 0x0F0F0F0F
    lu12i.w $t7, 0x01010
    ori     $t7, $t7, 0x101    # t7 = 0x01010101

    # 处理低 32 位 (t2)
    bstrpick.d $t2, $a0, 31, 0
    srli.w  $t0, $t2, 1
    and     $t0, $t0, $t4
    sub.w   $t2, $t2, $t0
    srli.w  $t0, $t2, 2
    and     $t0, $t0, $t5
    and     $t2, $t2, $t5
    add.w   $t2, $t2, $t0
    srli.w  $t0, $t2, 4
    add.w   $t2, $t2, $t0
    and     $t2, $t2, $t6
    mul.w   $t2, $t2, $t7
    srli.w  $t2, $t2, 24

    # 处理高 32 位 (t3)
    srli.d  $t3, $a0, 32
    srli.w  $t0, $t3, 1
    and     $t0, $t0, $t4
    sub.w   $t3, $t3, $t0
    srli.w  $t0, $t3, 2
    and     $t0, $t0, $t5
    and     $t3, $t3, $t5
    add.w   $t3, $t3, $t0
    srli.w  $t0, $t3, 4
    add.w   $t3, $t3, $t0
    and     $t3, $t3, $t6
    mul.w   $t3, $t3, $t7
    srli.w  $t3, $t3, 24

    # 结果相加
    add.d   $a0, $t2, $t3
    jirl    $zero, $ra, 0
}
